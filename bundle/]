from os import listdir,path,walk
import time
import bisect
#import vim
import public_completions as vf_public
from HTMLParser import HTMLParser

folder_map = {}


#TODO use bisect for insertion points
public_completions = vf_public.getPublicCompletions()

#public_symbols = [(key,public_completions[key]) for key in public_completions]


public_symbol_keys = [(key) for key in public_completions]
public_symbol_keys.sort()
public_symbol_values = [(public_completions[key]) for key in public_symbol_keys]
public_symbols = (public_symbol_keys,public_symbol_values)


user_symbol_map = {}
user_symbol_keys = []
user_symbol_values = []
user_symbols = (user_symbol_keys,user_symbol_values)
user_symbols_changed = False
symbol_keys = []
symbol_values = []
symbols = (symbol_keys,symbol_values)
symbols[0].extend(public_symbols[0])
symbols[1].extend(public_symbols[1])
#symbols = []
#symbols.extend(public_symbol_values)
#symbol_keys = []
#symbol_keys.extend(public_symbol_keys)


def sort_key_pairs (tup):
    zip(*sorted(zip(tup[0],tup[1])))

def search_key_pairs (tup,value):
    a = tup[0]
    i = bisect.bisect_right(a, value)
    if i:
        return i-1
    raise ValueError


class ComponentParser(HTMLParser):
    def __init__ (self):
        self.tags = []
        self.needs_sorting = []
        HTMLParser.__init__(self)
    def handle_starttag(self,tag,attrs):
        global user_symbols_changed
        length = len(self.tags)
        self.tags.append(tag)
        if length == 0 and tag == 'apex:component':
            if not self.name in user_symbol_map:
                symbol_item = user_symbol_map[self.name] = {'attribs' : ([],[])}
                user_symbol_keys.append(self.name)
                user_symbol_values.append(symbol_item)
                #user_symbols.append((self.name,symbol_item))
                user_symbols_changed = True
            else:
                symbol_item = user_symbol_map[self.name]
                #TODO
                attribs = symbol_item['attribs']
                del attribs[0][0:len(attribs)]
                del attribs[1][0:len(attribs)]
                #attribs.clear()
        elif length == 1 and tag == 'apex:attribute':
            symbol_item = user_symbol_map[self.name]
            attribs = symbol_item['attribs']
            attribute = {}
            #make sure attribute has name, and type
            for attr in attrs:
                attribute[attr[0]] = attr[1]

            if attribute['name']:
                attribs[0].append(attribute['name'])
                attribs[1].append(attribute)
                self.needs_sorting.append(attribs)
                #attribs[attribute['name']] = attribute

    def handle_endtag(self,tag):
        if len(self.tags) > 0:
            self.tags.pop()
    def parse(self,name,value):
        global user_symbols_changed
        user_symbols_changed = False
        self.reset()
        self.name = name
        self.feed(value)
    def feed(self,value):
        HTMLParser.feed(self,value)
    def reset(self):
        del self.needs_sorting[0:len(self.needs_sorting)]
        del self.tags[0:len(self.tags)]
        self.name = ''
        HTMLParser.reset(self)

component_parser = ComponentParser()

NONE = 0
EMMET = 1
ELEMENT = 2
NAME = 4
ATTRIBUTE = 8
D_QUOTE = 16
S_QUOTE = 32
TEXT = 64
MULTIPLIER = 128
END = 256

visualforce_extensions = ['.component','.page','.vfp','.vfc']

def getOtherFiles(project,excluded_name):
    file_names = []
    for (dir_path,dir_names,files) in walk(project):
        [(file_names.append(path.join(dir_path,file).replace('\\','/'))) for file in files]
    if excluded_name in file_names:
        file_names.remove(excluded_name)
    return file_names

def parseComponents(project,file_names):
    if not project in folder_map:
        folder_map[project] = {}
    active_folder = folder_map[project]
    active_keys = active_folder.keys()

    for file_name in file_names:
        file_split = path.splitext(file_name)
        extension = file_split[1]
        if extension in visualforce_extensions:
            mtime = path.getmtime(file_name)
            #vim.command('let g:visualforce_found_valid_extension=1')
            if not file_name in active_folder:
                active_folder[file_name] = mtime
                if extension == '.component' or extension == '.vfc':
                    with open(file_name,'r') as f:
                        component_parser.parse('c:'+path.basename(file_split[0]),f.read())
            else:
                active_keys.remove(file_name)
                if mtime > active_folder[file_name] and (extension == '.component' or extension == '.vfc'):
                    active_folder[file_name] = mtime
                    with open(file_name,'r') as f:
                        component_parser.parse('c:'+path.basename(file_split[0]),f.read())

    for file_name in active_keys:
        file_name = path.splitext(file_name)[0]
        del active_folder[file_name]
        file_name = 'c:' + file_name
        if user_symbol_map[file_name]:
            del user_symbol_map[file_name]
            for i,(name) in user_symbol_keys:
                if name == file_name:
                    del user_symbol_keys[i]
                    del user_symbol_values[i]
                    break




    return (user_symbol_map,user_symbol_keys,user_symbols_changed)

def getCompletions(line,column,project,type,name,buffer):
    if not project in folder_map:
        folder_map[project] = {}

    #active_folder = folder_map[project]
    #active_keys = active_folder.keys()

    file_names = []
    for (dir_path,dir_names,files) in walk(project):
        [(file_names.append(path.join(dir_path,file))) for file in files]


    #vim.command('let g:visualforce_found_valid_extension=0')
    user_symbol_tup = parseComponents(project,getOtherFiles(project,name))
    if user_symbol_tup[2] == True:
        del symbol_keys[0:len(symbol_keys)]
        del symbol_values[0:len(symbol_values)]
        sort_key_pairs(user_symbols)
        #zip(*sorted(zip(user_symbol_keys,user_symbol_values)))
        symbol_keys.extend(public_symbol_keys)
        symbol_values.extend(public_symbol_values)
        symbol_keys.extend(user_symbols)
        symbol_values.extend(user_symbol_values)
        sort_key_pairs(symbols)
        #zip(*sorted(zip(symbol_keys,symbol_values)))

    #for file_name in file_names:
        #extension = path.splitext(file_name)[1]
        #if extension in visualforce_extensions:
            #mtime = path.getmtime(file_name)
            ##vim.command('let g:visualforce_found_valid_extension=1')
            #if not file_name in active_folder:
                #active_folder[file_name] = mtime
                #if extension == '.component' or extension == '.vfc':
                    #with open(file_name,'r') as f:
                        #component_parser.parse(file_name,f.read())
            #else:
                #active_keys.remove(file_name)
                #if mtime > active_folder[file_name] and (extension == '.component' or extension == '.vfc'):
                    #with open(file_name,'r') as f:
                        #component_parser.parse(file_name,f.read())


    #for file_name in active_keys:
        #del active_folder[file_name]
        #if symbol_map['c:'+file_name]:
            #del symbol_map['c:'+file_name]

    
    if (len(component_parser.needs_sorting)):
        for attrib in component_parser.needs_sorting:
            sort_key_pairs(attrib)
            #zip(*sorted(zip(attrib[0],attrib[1])))

    if type == 'vfc':
        component_parser.parse(''.join(buffer))

    if (len(component_parser.needs_sorting)):
        for attrib in component_parser.needs_sorting:
            sort_key_pairs(attrib)
            #zip(*sorted(zip(attrib[0],attrib[1])))

    class ElementState ():
        def __init__(self,state):
            self.persistent = self.state = state
            self.tag = ''
            self.s_quote_loc = -1
            self.d_quote_loc = -1
            self.text_loc = -1
            self.attribute_loc = -1
            self.name_loc = -1
        def get(self):
            return self.state
        def add(self,state):
            self.state = self.state | state
            self.persistent = self.persistent | state
            return self
        def has(self,state):
            return self.state & state
        def equals(self,state):
            return self.state == state
        def sub(self,state):
            self.state = self.state & ~state
            return self
        def had(self,state):
            return self.persistent & state
        def set(self,state):
            self.state = state
            self.persistent = self.persistent | state
            return self

    class States:
        def __init__(self,state):
            self.states = []
            self.open_d_quotes = 0
            self.open_s_quotes = 0
            self.escaped = False
            self.last_ch = ''
            self.next(state)
        def next(self,state):
            self.active = ElementState(state)
            self.states.append(self.active)
            return self.active
        def prev(self,state):
            ln = len(self.states)
            if ln > 1:
                self.states.pop()
                self.active = self.states[ln-1]
            return self.active


    active_line = buffer[line]
    states = States(NONE)
    line_ln = len(active_line)

    def parse_element(ch):
        active = states.active
        if active.has(ATTRIBUTE):
            if ch == '[':
                active.add(EMMET)
                #adjust loc
            elif ch == "\'":
                states.next(S_QUOTE)
            elif ch == "\"":
                states.next(D_QUOTE)
        elif active.has(NAME):
            if active.has(S_QUOTE):
                quote_loc = active.s_quote_loc
                if ch == '\\':
                    states.escaped = True
                elif ch == '\'':
                    states.prev().s_quote_loc = s_quote_loc
                elif active.s_quote_loc == -1:
                    active.s_quote_loc = index
            elif active.has(D_QUOTE):
                quote_loc = active.d_quote_loc
                if ch == '\\':
                    states.escaped = True
                elif ch == '\'':
                    states.prev().d_quote_loc = d_quote_loc
                elif active.d_quote_loc == -1:
                    active.d_quote_loc = index
            if ch == ' ' or ch =='\t':
                active.sub(NAME)
                active.add(ATTRIBUTE)
            elif ch == '[':
                if last_ch == ' ' or last_ch == '\t' or last_ch == '\'' or last_ch == '\"':
                    states.next(EMMET | ATTRIBUTE)
                else:
                    active.add(EMMET | ATTRIBUTE)
            elif ch == '/' and len(active_state.tag) == 0:
                active.add(END)
            elif ch == '>':
                states.next(NONE)
            else:
                active.tag += ch

    def parse_emmet(ch):
        active = states.active
        print 'char=' + ch + ' tag=' + active.tag
        if active.has(ATTRIBUTE):
            if ch == ']':
                active.sub(ATTRIBUTE)
            elif ch == '\'':
                states.next(S_QUOTE)
            elif ch == '\"':
                print active.get()
                states.next(D_QUOTE)
        else:
            if ch == '\\':
                states.escaped = True
                return
            elif active.has(TEXT):
                text_loc = active.text_loc
                if ch == '}':
                    states.prev().text_loc = text_loc
                elif active.text_loc == -1:
                    active.text_loc = index
            elif active.has(S_QUOTE):
                quote_loc = active.s_quote_loc
                if ch == '\'':
                    states.prev().s_quote_loc = s_quote_loc
                elif active.s_quote_loc == -1:
                    active.s_quote_loc = index
            elif active.has(D_QUOTE):
                quote_loc = active.d_quote_loc
                if ch == '\"':
                    states.prev().d_quote_loc = d_quote_loc
                elif active.d_quote_loc == -1:
                    active.d_quote_loc = index

            if active.has(NAME) and (ch ==' ' or ch =='\t' or ch =='"' or ch == '\''):
                states.next(NONE)
            elif ch == '\\':
                states.escaped = True
            elif ch == '[':
                if active.had(TEXT | ATTRIBUTE):
                    states.next(NONE)
                else:
                    active.add(ATTRIBUTE)
            elif ch == '{':
                if active.had(TEXT):
                    states.next(NONE)
                else:
                    active.add(TEXT).sub(TEXT)
                    states.next(TEXT)
            elif ch == '>' or ch == '^':
                states.next(NONE)
            elif ch == '*':
                active.add(MULTIPLIER)
            else:
                if active.has(NAME):
                    if active.name_loc == -1:
                        active.name_loc = index
                    active.tag += ch
                elif active.has(MULTIPLIER) and (ord(ch) < 48 or ord(ch) > 57):
                    states.next(NONE)

    index = 0 
    for index in range(0,min(column,line_ln-1)):
        ch = active_line[index]
        active = states.active
        if not active.has(ELEMENT):
            if ch == ' ' or ch == '\t':
                continue
            elif ch == '<':
                active.add(ELEMENT | NAME)
            else:
                active.add(EMMET | ELEMENT | NAME)
                parse_emmet(ch)
        elif states.escaped == True:
            states.escpaed = False
            continue
        elif active.has(EMMET):
            parse_emmet(ch)
        else:
            parse_element(ch)
        last_ch = ch

    #print active.has(ELEMENT)
    #print active.has(NAME)
    #print active.tag
    #print active.has(ATTRIBUTE)
    #print active.has(EMMET)
    #print active.has(D_QUOTE)
    

    def get_matching_key_pair_range (tup,value):
        target = tup[0]
        start = search_key_pairs(symbols,active.tag)
        start_range = -1
        end_range = -1
        if target[start] != value:
            start += 1
        for index in range(start,len(target)):
            if (target[index].startswith(value) != True):
                break
            elif start_range == -1:
                start_range = index

        if start_range != -1:
            end_range = index

        return range(start_range,end_range)


    result = []
    if states.active.has(NAME):
        range_value = get_matching_key_pair_range(symbols,active.tag)
        for i in range_value:
            result.append({"abbr":symbol_keys[i],"icase":1,"dup":1,"word":symbol_keys[i]})

    print result
    return result



    #symb
    #now return completions based on active state
    #if active.equals(NONE):
        #suggest everything
    #elif active.has(NAME):
        #suggest names that match
        #TODO names that match parentTag
    #elif active.has(ATTRIBUTE):
        #if has end - suggest nothing
        #suggest attributes that match tag
    #elif active.has(MULTIPLIER)
        #suggest every name
